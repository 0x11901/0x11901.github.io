[{"title":"Haskell在macOS下的环境搭建","url":"/2018/06/22/Haskell在macOS下的环境搭建/","content":"Haskell作为一个冷门语言，并没有一个简单好用傻瓜式的IDE。所以笔者记录了自己搭建环境的过程，希望对大家有所帮助。\n\n## 准备工作\n1. 一个好的网络环境，至少与GitHub保持通畅连接\n2. [Homebrew](https://brew.sh/)\n\n## 开发环境的搭建\n\n### 编译器(GHC)、解释器(GHCI)等Haskell工具链\n在笔者踩过无数坑之后，无脑推荐[Haskell Stack](https://docs.haskellstack.org/en/stable/README/)，喜欢挑战的读者可以自行尝试使用GHC+GHCI+[Cabal](https://www.haskell.org/cabal/)开发环境\n    `brew install haskell-stack`\n\n### 编辑器\n目前主流的编辑器有vim, emacs, sublime, atom, visual studio code等，笔者平日开发中只在修改配置文件或者替换某个字符串时用到它们故先按下不表。\n\n### IDE\n因为宇宙最强IDE——[Visual Studio](https://www.visualstudio.com/)在Mac上发力较晚并表现不佳，故笔者建议使用[IntelliJ IDEA](https://www.jetbrains.com/idea/)(虽说笔者非常讨厌Java这门语言，但是不得不承认Java写出来的工具还是有不少好用的)\n\n#### HaskForce\nIntelliJ IDEA有两个第三方插件提供了对Haskell的支持，笔者建议使用评分较高的[HaskForce](http://haskforce.com/)，目前这款插件已经无人维护(存疑，但也侧面反映了Haskell社区的现状)\n\n* 安装\n    1. 在IntelliJ IDEA中按下 ⌘ + , 进入偏好设置界面\n    2. > Plugins > Browse repositories > HaskForce\n\n* 使用\n    由于 HaskForce 插件自身的局限性，需要在终端中通过 Haskell Stack 创建项目。\n    1. `stack new 项目名称 模版名称 路径(默认当前路径)`\n    2. `cd 项目名称`\n    3. `stack setup`\n    4. `stack build` \n\n*注意如果在创建项目中提示参数不足的警告，可以在~/.stack/config.yaml中配置*\n\n```yaml\ntemplates:\n  params:\n    author-name: your-name\n    author-email: your-email\n    copyright: 'Copyright (c) 2018 0x11901'\n    github-username: '0x11901'\n    category: categories\n```\n\n*不建议在此写死模版名称，如果不是很确定要用什么模版，可以在新建项目时传simple*\n\n* 使用 IntelliJ IDEA 导入创建的 Haskell Stack 项目\n\n  1. 路径选择项目的根目录，注意一下是不是选择了 Stack 模块\n  2. 然后一直下一步\n  3. 配置下 configurations\n  4. `> add > Haskell Stack Run > Executable:  项目名称`\n  5. Executable一定要填写\n\n* 点击 run 就能运行你的Haskell程序了！\n\n### 相关工具\n如果仅仅只有这些虽然就能愉快的编码了，但是笔者认为是完全不够的。毕竟如果没有代码格式化工具和静态代码分析工具，笔者是不会写代码的。所以怎么能少了这些呢！！！\n刚好 HaskForce 整合了 hlint, ghc-mod, hindente 等相关 Haskell 工具，可以很好地与 IntelliJ IDEA 结合。它们的安装也十分简单，可以直接使用 Haskell Stack 安装，当然 hlint 也可以使用 Homebrew 安装，不过笔者建议使用统一的安装方式方便将来管理。\n\n`stack install hlint hindente stylish-haskell`\n\n其中 ghc-mod 的安装值得特别说一下，目前新建的 Haskell Stack 工程默认的 resolver 是 lts-11.6 , 其 GHC 的版本号是 8.2.2 , 而 ghc-mod 的主工程由于[技术问题](https://github.com/DanielG/ghc-mod/issues/900)一直没有支持这套环境，所以想要成功编译出来是很麻烦的。所以如果大家想使用这款令人愉悦的黑客工作，可以按照下列步骤来编译。\n\n    1. 推荐建立一个独立的目录来存储接下来要使用的文件，编译完成后即可删除\n    2. cd 你刚刚建的目录\n    3. git clone https://github.com/DanielG/ghc-mod.git -b ghc802\n    4. git clone https://github.com/DanielG/cabal-helper.git\n    5. cd ghc-mod ; touch stack.yaml\n\n因为通过 Haskell Stack 来编译 ghc-mod 需要配置一个 stack.yaml , 所以用你最喜欢的编译器打开 stack.yaml 并写上下面的内容：\n\n```yaml\nresolver: lts-11.6 # current resolver\n\npackages:\n- location: .\n- location: ./core # seems like ghc-mod-core got integrated\n- location: ../cabal-helper\n  extra-dep: true\n\nextra-deps: \n- extra-1.6.6 # escapeJSON was missing with 1.5.3\n- monad-journal-0.7.2\n- optparse-applicative-0.13.2.0\n- unix-compat-0.4.3.1\n- either-4.4.1.1\n- cabal-plan-0.3.0.0\n\nflags: {}\n\nextra-package-dbs: []\n\nallow-newer: true # so it builds / too lazy to pinpoint exact versions\n```\n\n现在在当前目录使用 `stack install` 命令即可正常编译出 ghc-mod 与 ghc-modi 并会被放在 `~/.local/bin ` 目录下，你可以将这个目录加入 shell 的环境变量中也可以把它们移到已经加到 shell 的环境变量的目录下。\n\n最后打开 IntelliJ IDEA 的进入偏好设置界面界面，找到 Haskell Tools 一栏，然后找到你想要使用的工具，点击 Auto Find 按钮然后确认，就能在 IntelliJ IDEA 使用这些工具了！"},{"title":"利用iCloud Drive来同步Xcode配置","url":"/2018/05/11/利用iCloud-Drive来同步Xcode配置/","content":"\n## 前言\n多年以前一位老程序员告诉笔者代码片段（code snippets）是程序员的财富，他有一个U盘，里面装着他的财富。每当他需要切换电脑写代码的时候，他就会把把精心配置的字体、主题、代码片段等部署到新电脑上，然后开始高速编码。每次看他写代码都是一种享受，不过这是另一个故事了。\n## 需求\n多年之后，笔者也终于凑够了钱买了自己的Mac，闲暇无事的时候也会写写代码祭奠下逝去的青春。但是某些时候总会觉得很别扭，例如感觉字体和单位的有细小的差距，或者一个代码片段怎么也按不出来——最后发现是没有在这台电脑配置这段代码片段。这种事发生的事情多了之后，就会感觉厌烦，同样的操作为什么得重复两次、三次？或者拿出吃了几年灰的U盘抽插在各地的电脑上人工同步？就不能有什么办法可以一次更改多次应用？笔者稍微一拍脑门，想到了今天的主角——iCloud Drive\n\n1. 为什么使用iCloud Drive？\n    * 因为这是苹果本家的网盘，嵌入系统中，只要开启我们就无需关心上传下载，正如OneDrive在Windows一样，我们只需要把文件放进去，他就会自动开始上传，并在你的每一台苹果设备上同步。利用这点我们就能方便的做到在不同的设备上同步Xcode配置文件，无需手动同步或者上传下载。\n2. 其他的替代方案\n    * GitHub之类的大型同性交友网站\n        * 目前想来用git应该更好更方便，不过实现起来有点复杂，有能力的朋友可以自己动手\n    * OneDrive/坚果云等网盘\n        * 我觉得能有自带的还是用自带的吧\n\n## 思路\n总所周知Xcode的代码片段是保存在`~/Library/Developer/Xcode/UserData/CodeSnippets`路径下的，附近位置还有主题等配置信息。基于笔者的经验我们只需要备份同级目录下的CodeSnippets、FontAndColorThemes和KeyBindings三个子目录就行了。每当我们修改了代码片段、主题或者快捷键，把对应的文件放在iCloud Drive同步，当在其他电脑上时就使用最新的覆盖到对应目录即可。\n## 脚本\n虽说思路如此，但是笔者肯定不敢把这种三岁小孩子就能分析出来的东西发出来糊弄人。所以为了简化这个繁琐而又机械的操作，笔者编写了这样一个脚本：\n\n```bash\n#!/usr/bin/env bash\n\nset -euo pipefail\n\n################# variable define ##########\nnow=`date \"+%Y%m%d%H%M%S\"`\n\nred=`tput setaf 1`\ngreen=`tput setaf 2`\nyellow=`tput setaf 3`\nreset=`tput sgr0`\n\nxcode_dir=\"${HOME}/Library/Developer/Xcode/UserData\"\ncloud_backup_dir=\"${HOME}/Library/Mobile Documents/com~apple~CloudDocs/XcodeBackup\"\nlocal_backup_dir=\"${HOME}/资源/归档/XcodeBackup\"\n\ncode_snippets=\"CodeSnippets\"\nfont_and_color_themes=\"FontAndColorThemes\"\nkey_bindings=\"KeyBindings\"\n\n########### MAIN ##################\n# check directory exist\nif [ ! -d \"${cloud_backup_dir}\" ]; then\n    echo \"${red}iCloud Drive备份路径不存在！${reset}\"\n    mkdir -p \"${cloud_backup_dir}\"\n    echo \"${green}自动创建iCloud Drive备份路径：${reset}${cloud_backup_dir}\"\n    else\n    echo \"${green}iCloud Drive备份路径:${reset}${cloud_backup_dir}\"\nfi\n\nif [ ! -d \"${local_backup_dir}\" ]; then\n    echo \"${red}本地备份路径不存在！${reset}\"\n    mkdir -p \"${local_backup_dir}\"\n    echo \"${green}自动创建本地备份路径：${reset}${local_backup_dir}\"\n    else\n    echo \"${green}本地备份路径:${reset}${cloud_backup_dir}\"\nfi\n\n# zip files\ncd \"${xcode_dir}\"\nzip -r \"${cloud_backup_dir}/XcodeBackup+${now}.zip\" \"${code_snippets}\" \"${font_and_color_themes}\" \"${key_bindings}\" &\nzip -r \"${local_backup_dir}/XcodeBackup+${now}.zip\" \"${code_snippets}\" \"${font_and_color_themes}\" \"${key_bindings}\" &\n\nwait\n\n# delete unnecessary backup files\nnum=`ls -l \"${cloud_backup_dir}\" |grep \"^-\"|wc -l`\nif [ ${num} -gt 5 ]; then\n    num=`expr ${num} - 5`\n    cd \"${cloud_backup_dir}\"\n    ls -tr \"${cloud_backup_dir}\" | head -${num} | xargs rm\nfi\n\nnum=`ls -l \"${local_backup_dir}\" |grep \"^-\"|wc -l`\nif [ ${num} -gt 5 ]; then\n    num=`expr ${num} - 5`\n    cd \"${local_backup_dir}\"\n    ls -tr \"${local_backup_dir}\" | head -${num} | xargs rm\nfi\n```\n\n简化了这个繁琐的操作，仅需在开机的时候跑一下，就能达到自动备份的效果。功能也是十分的简单：\n\n1. 首先创建了两个备份Xcode配置文件的路径，一个在云端，一个在本地（本地路径大家可以自行配置，一般也不会用上）。\n2. 然后把Xcode归档到这两处各一份，笔者这里选用zip包而不是更高压缩比的7zip等是因为想做通用一点便于大家开箱即用，不需要额外安装其他软件。\n3. 最后将多次运行后生成的老包删除，只保留最新的5个，以便节约宝贵的空间（毕竟笔者比较穷只舍得用免费的5g版）\n\n有了这个脚本之后，大家只需要坚持开机的时候跑一跑就行了。笔者喜欢每天开机就更新下cocoapods、brew、brew cask这类的，所以就写了个脚本，刚好顺便也就备份一下。脚本思路大致如下，因为和主题无关就不细说了。\n\n```bash\n#!/usr/bin/env bash\n\nopen 自用魔法丝袜之影\n\nwait\n\npod repo update --verbose &\n更新Homebrew cask &\n备份各种币钱包 &\n\n备份Xcode等IDE配置文件 &\n\nwait\n\nkillall 自用魔法丝袜之影\n```\n\n不过这样其实也不是很方便，毕竟打开terminal输入指令都很烦了，难道还要手动计算这台电脑的配置是否是最新的？然后再考虑是不是需要把云盘里面的配置解压到指定的位置覆盖？而且很有可能在做这些前已经把这台电脑的配置当最新版上传到云盘里了。\n## 让所有的电脑用同一个版本的配置\n笔者再次进行了思考。如果可以根据这些文件的最后修改日期和备份的文件进行比较，谁新就用哪个版本，那么不就实现了吗？只要我们确保每次修改都跑一次脚本，每次开机都跑一次，就能达到我们想要的效果了。至于如何判断文件的最后修改时间，笔者认为只需要一个根据文件名生成的key和一个对应的文件的最后修改时间做value的数据结构就行了（虽说也可以把备份的文件展开比较，但是因为笔者才疏学浅，尚不知如何操作，就只能通过键值对来判断了）\n不过实际操作起来，再次彰显了笔者的才疏学浅，笔者也不知道如何在bash中创建一个高效并能持久化的键值对，如果哪位大佬知道请务必告诉笔者。\n最后笔者想到Mac自带的SQLite3，虽说这样一个小小的功能上数据库是有一点高射炮打蚊子，但是能跑就行吧。脚本如下；\n\n```bash\n#!/usr/bin/env bash\n\nset -euo pipefail\n\n################# variable define ##########\nnow=`date \"+%Y%m%d%H%M%S\"`\n\nred=`tput setaf 1`\ngreen=`tput setaf 2`\nyellow=`tput setaf 3`\nreset=`tput sgr0`\n\nxcode_dir=\"${HOME}/Library/Developer/Xcode/UserData\"\ncloud_backup_dir=\"${HOME}/Library/Mobile Documents/com~apple~CloudDocs/XcodeBackup\"\nlocal_backup_dir=\"${HOME}/资源/归档/XcodeBackup\"\n\nxcode_backup_database=\"${HOME}/Library/Mobile Documents/com~apple~CloudDocs/.BackupDatabase\"\n\ncode_snippets=\"CodeSnippets\"\nfont_and_color_themes=\"FontAndColorThemes\"\nkey_bindings=\"KeyBindings\"\n\ntemp=\"DoNotModify\"\ndatabase=\"${xcode_backup_database}/${temp}\"\n\n########### MAIN ##################\n# check directory exist\nif [ ! -d \"${cloud_backup_dir}\" ]; then\n    echo \"${red}iCloud Drive备份路径不存在！${reset}\"\n    mkdir -p \"${cloud_backup_dir}\"\n    echo \"${green}自动创建iCloud Drive备份路径：${reset}${cloud_backup_dir}\"\nelse\n    echo \"${green}iCloud Drive备份路径:${reset}${cloud_backup_dir}\"\nfi\n\nif [ ! -d \"${local_backup_dir}\" ]; then\n    echo \"${red}本地备份路径不存在！${reset}\"\n    mkdir -p \"${local_backup_dir}\"\n    echo \"${green}自动创建本地备份路径：${reset}${local_backup_dir}\"\nelse\n    echo \"${green}本地备份路径:${reset}${cloud_backup_dir}\"\nfi\n\nif [ ! -d \"${xcode_backup_database}\" ]; then\n    echo \"${red}同步数据库路径不存在！${reset}\"\n    mkdir -p \"${xcode_backup_database}\"\n    echo \"${green}自动创建数据库路径：${reset}${local_backup_dir}\"\nelse\n    echo \"${green}数据库路径:${reset}${cloud_backup_dir}\"\nfi\n\nsqlite3 \"${database}\" 'create table if not exists backupXcode(id integer primary key not NULL,key integer unique not NULL,value integer not NULL);'\n\n#获取最后修改时间\ncd \"${xcode_dir}\"\nif [ -d \"./${code_snippets}\" ]; then\n    find \"./${code_snippets}\" -type f >> ${temp}\nfi\nif [ -d \"./${font_and_color_themes}\" ]; then\n    find \"./${font_and_color_themes}\" -type f >> ${temp}\nfi\nif [ -d \"./${key_bindings}\" ]; then\n    find \"./${key_bindings}\" -type f >> ${temp}\nfi\n\nwhile read path; do\n    key=`md5 -q -s \"${path}\"`\n    value=`stat -f \"%m\" \"${path}\"`\n    isModify=`sqlite3 \"${database}\" \"select value from backupXcode where key == '${key}';\"`\n    if [ -z ${isModify} ]; then\n        echo \"${yellow}本地Xcode配置尚未同步${reset}！\"\n        num=`ls -l \"${cloud_backup_dir}\" |grep \"^-\"|wc -l`\n        if [ ${num} -ge 1 ]; then\n            echo \"${green}找到最新的Xcode配置，开始自动替换${reset}！\"\n            \n            cd \"${xcode_dir}\"\n            ## backup before\n            zip -r \"XcodeBackup.zip\" \"${code_snippets}\" \"${font_and_color_themes}\" \"${key_bindings}\" &\n            wait\n            \n            cd \"${cloud_backup_dir}\"\n            newBackup=`ls -t | head -1`\n            \n            unzip -u \"${newBackup}\" -d \"${xcode_dir}\" &\n            wait\n            \n            cd \"${xcode_dir}\"\n            rm ${temp}\n            if [ -d \"./${code_snippets}\" ]; then\n                find \"./${code_snippets}\" -type f >> ${temp}\n            fi\n            if [ -d \"./${font_and_color_themes}\" ]; then\n                find \"./${font_and_color_themes}\" -type f >> ${temp}\n            fi\n            if [ -d \"./${key_bindings}\" ]; then\n                find \"./${key_bindings}\" -type f >> ${temp}\n            fi\n            echo 更新数据库...\n            while read path; do\n                key=`md5 -q -s \"${path}\"`\n                value=`stat -f \"%m\" \"${path}\"`\n                sqlite3 \"${database}\" \"insert or replace into backupXcode values(NULL,'${key}',${value});\" &\n            done < ${temp}\n        fi\n        break\n    fi\n    if [ ${isModify} != ${value} ]; then\n        if [ ${isModify} -gt ${value} ]; then\n            echo \"${yellow}本地Xcode配置超前${reset}！\"\n        else\n            echo \"${yellow}本地Xcode配置已经过期${reset}！\"\n            \n            num=`ls -l \"${cloud_backup_dir}\" |grep \"^-\"|wc -l`\n            if [ ${num} -ge 1 ]; then\n                echo \"${green}找到最新的Xcode配置，开始自动替换${reset}！\"\n                \n                cd \"${xcode_dir}\"\n                ## backup before\n                zip -r \"XcodeBackup.zip\" \"${code_snippets}\" \"${font_and_color_themes}\" \"${key_bindings}\" &\n                wait\n                \n                cd \"${cloud_backup_dir}\"\n                newBackup=`ls -t | head -1`\n                \n                unzip -o \"${newBackup}\" -d \"${xcode_dir}\" &\n                wait\n            fi\n        fi\n        cd \"${xcode_dir}\"\n        rm ${temp}\n        if [ -d \"./${code_snippets}\" ]; then\n            find \"./${code_snippets}\" -type f >> ${temp}\n        fi\n        if [ -d \"./${font_and_color_themes}\" ]; then\n            find \"./${font_and_color_themes}\" -type f >> ${temp}\n        fi\n        if [ -d \"./${key_bindings}\" ]; then\n            find \"./${key_bindings}\" -type f >> ${temp}\n        fi\n        echo 更新数据库...\n        while read path; do\n            key=`md5 -q -s \"${path}\"`\n            value=`stat -f \"%m\" \"${path}\"`\n            sqlite3 \"${database}\" \"insert or replace into backupXcode values(NULL,'${key}',${value});\"\n        done < ${temp}\n        break\n    fi\ndone < ${temp}\n\nwait\nrm ${temp}\n\n# zip files\ncd \"${xcode_dir}\"\nzip -r \"${cloud_backup_dir}/XcodeBackup+${now}.zip\" \"${code_snippets}\" \"${font_and_color_themes}\" \"${key_bindings}\" &\nzip -r \"${local_backup_dir}/XcodeBackup+${now}.zip\" \"${code_snippets}\" \"${font_and_color_themes}\" \"${key_bindings}\" &\n\nwait\n\n# delete unnecessary backup files\nnum=`ls -l \"${cloud_backup_dir}\" |grep \"^-\"|wc -l`\nif [ ${num} -gt 5 ]; then\n    num=`expr ${num} - 5`\n    cd \"${cloud_backup_dir}\"\n    ls -tr \"${cloud_backup_dir}\" | head -${num} | xargs rm\nfi\n\nnum=`ls -l \"${local_backup_dir}\" |grep \"^-\"|wc -l`\nif [ ${num} -gt 5 ]; then\n    num=`expr ${num} - 5`\n    cd \"${local_backup_dir}\"\n    ls -tr \"${local_backup_dir}\" | head -${num} | xargs rm\nfi\n```\n\n## 后记\n笔者简单测试了一下，基本上能用。以此思路，应该也可用在Alfred、vimrc等配置文件。不过依旧不是很方便，不过笔者才疏学浅，目前也就这个水平了，希望能对大家有所帮助，不知道大家有没有什么好的建议？笔者认为可以在Xcode关闭时自动运行本脚本，但是尚未找到好的胡克点_(:_」∠)_，如果大家有什么好的建议，欢迎[PR](https://github.com/0x11901/Scripts/blob/master/BackupXcode.sh)\n\n就这样吧，下台鞠躬！！！\n"},{"title":"如何使用Logos优雅的注入Mac app","url":"/2018/02/10/如何使用Logos优雅的注入Mac-app/","content":"\n## 前言\nLogos是[Theos](https://github.com/theos/theos)的一个组件，它允许程序员使用一组特殊的预处理器指令来编写钩子，简洁高效。\n做过iOS逆向开发的朋友应该非常熟悉，这里笔者将介绍如何在Mac app上使用Logos。\n\n## 可能用到的工具\n1. [Theos](https://github.com/theos/theos)\n2. [optool](https://github.com/alexzielenski/optool)/[insert_dylib](https://github.com/Tyilo/insert_dylib)\n3. [unsign](https://github.com/steakknife/unsign) (optional)\n\n## 一个简单的例子\n* 编写一个简单的demo，大概就是\b\b软件正中一个按钮，点击之后alert(\"hi!\")\b。核心代码如下：\n\n    ```objc\n    #import \"ViewController.h\"\n    \n    @implementation ViewController\n    \n    - (void)viewDidLoad {\n        [super viewDidLoad];\n    \n        // Do any additional setup after loading the view.\n    }\n    \n    - (IBAction)sayHi:(NSButton *)sender {\n        NSAlert *alert = NSAlert.new;\n        alert.messageText = @\"hi!\";\n        alert.alertStyle = NSAlertStyleInformational;\n        [alert runModal];\n    }\n    \n    \n    - (void)setRepresentedObject:(id)representedObject {\n        [super setRepresentedObject:representedObject];\n    \n        // Update the view, if already loaded.\n    }\n    \n    \n    @end\n    ```\n    ![效果图](http://ooph3gs8p.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-10%2021.53.36.png)\n\n我们的目标是注入sayHi这个方法，使点击按钮之后不再说“hi!”，而是“hello world!”\n* 编写Logos\n\n    ```objc\n    %config(generator=internal)  // ★★加上这句★★\n    \n    // You don't need to #include <substrate.h>, it will be done automatically, as will\n    // the generation of a class list and an automatic constructor.\n    #import <Foundation/Foundation.h>\n    \n    %hook ViewController\n    \n    \n    // Hooking an instance method with an argument.\n    - (void)sayHi:(id)argument {\n        NSAlert *r15 = [[NSAlert alloc] init];\n        [r15 setMessageText:@\"hello world!\"];\n        [r15 setAlertStyle:0x1];\n        [r15 runModal];\n    }\n    \n    \n    \n    // Always make sure you clean up after yourself; Not doing so could have grave consequences!\n    %end\n    \n    %ctor {\n        NSLog(@\"!!!!!!inject success!!!!!!!\");\n    }\n    ```\n    将以上代码保存为一个Tweak.xm文件(名字后缀名随意)，放在与SayHi.app同级目录下，便于后续操作。\n\n* 然后我们使用Theos的语法分析来把Logos转换成普通代码\n  `$THEOS/bin/logos.pl Tweak.xm > abc.mm`\n  *注意abc应该有mm作为后缀名，用于告诉clang目标语言类型*\n\n* 使用clang编译转换后的普通代码，并将结果放到app包内\n    `clang -shared -undefined dynamic_lookup -o ./SayHi.app/Contents/MacOS/lib.dylib ./abc.mm`\n\n* 使用optool/insert_dylib往SayHi的MachO头部添加我们刚刚编译的lib.dylib\n    `optool install -c load -p @executable_path/lib.dylib -t ./SayHi.app/Contents/MacOS/SayHi`\n\n如果你的Mac app没有签名的话，此时应该已经达成我们的需求了。但是实践中我们肯定不是对自己导出的未签名Mac app下黑手。所以需要去掉这个签名或重签名。因为笔者没有钱买开发者账号，故不知道如何重签名。\n\n* 使用codesign去除签名\n  `codesign --remove-signature SayHi.app `\n\n此时我们的需求已经达成\n![大成功](http://ooph3gs8p.bkt.clouddn.com/屏幕快照 2018-02-10 23.14.23.png)\n但是codesign有一个bug，在删除代码签名之后没有修复MachO Header的偏移，会导致生成的MachO文件畸形。笔者曾经就遇见一个不到1m的小程序在移除签名后膨胀到2g大小。\n所以笔者建议使用开源社区的代替方案——[unsign](https://github.com/steakknife/unsign) \n\n## 后记\n笔者把上面的繁琐命令行操作整合为一个脚本，在这里也顺便分享出来\n\n```bash\n#!/usr/bin/env bash\n\n#将xm和文件app包放在同一个目录，运行本脚步进行注入\n\npath=`ls | grep *.app | head -1`\ntweak=`ls | grep *.xm | head -1`\ntemp='x11901'\nname=${path%.app}\n\n$THEOS/bin/logos.pl \"./${tweak}\" > \"./${temp}.mm\"\nclang -shared -undefined dynamic_lookup -o \"./${path}/Contents/MacOS/lib.dylib\" \"./${temp}.mm\"\noptool install -c load -p @executable_path/lib.dylib -t \"./${path}/Contents/MacOS/${name}\"\n\nrm -f ${temp}.mm\n\n# 使用unsign效果可能更好，codesign --remove-signature 在删除代码签名之后没有修复MachO Header的偏移，导致生成的MachO文件畸形\n# codesign --remove-signature ${name}\nif [ ! -e \"./${path}/Contents/MacOS/${name}.ori\" ]; then\n    unsign \"./${path}/Contents/MacOS/${name}\"\n    mv \"./${path}/Contents/MacOS/${name}\" \"./${path}/Contents/MacOS/${name}.ori\"\n    mv \"./${path}/Contents/MacOS/${name}.unsigned\" \"./${path}/Contents/MacOS/${name}\"\nfi\n\nopen \"./${path}/Contents/MacOS/${name}\"\n```\n---\n[下载Demo](https://github.com/0x11901/SayHi)\n"},{"title":"重温《EVA》TV版25、26集有感","url":"/2018/02/07/重温《EVA》TV版25、26集有感/","content":"\n![header](http://ooph3gs8p.bkt.clouddn.com//20171028000424_hOICiM_maxresdefault.jpeg \"头图\")\n\n\n\n《**新世纪福音战士**》，简称《**EVA**》是我非常喜爱的一部动漫。最近在闲暇之余重温了其TV版25、26话，比起年少时多了几分感慨，故记录下来，方便日后回味\n\n虽说是想写点什么，但是实际写的时候完全不知从何下笔，所以按照影片的时间顺序结合我个人的分析起笔吧。但是在继续这个话题之前，我提出两个假设，以下的观点讲建立在这两个假设之下：\n\n 1. TV版25、26话与剧场版《The End of Evangelion》（简称EoE）讲诉了同一个故事，只是表现形式不同，即TV版描述了EoE中真嗣等人在“人类补完计划”前后的心理活动\n\n     *注：本条假设基于24话下集预告中出现的分镜和解说与剧场版Air高度一致，证明剧场版剧本早已完成*\n\n     ![Air](http://ooph3gs8p.bkt.clouddn.com//20171028215724_EGLFHF_屏幕快照%202017-10-28%20下午9.55.56.png \"Air\")\n\n 2. 作者主要以真嗣的心理\n\n## 真嗣\n\n25话一开头就打出了 *存在理由、レゾンデートル* 一行白字，除了告诉观众我们已经没钱了之外，也揭示了本小结的主题——真嗣存在的理由？![*存在理由、レゾンデートル* ](http://ooph3gs8p.bkt.clouddn.com//20171028212819_J9iNDG_屏幕快照%202017-10-28%20下午9.28.10.png \"*存在理由、レゾンデートル* \")\n\n> 存在的理由，可以待在这里的理由，碇真嗣他的情况\n>\n> 少年期望的死亡\n>\n> 少年达成他的愿望\n>\n> 最后的使徒消灭了\n> 可是，碇真嗣很苦脑\n> 为什么杀掉\n> ……\n>\n\n结合以前的剧情，很容易知道真嗣认为自己是不应该继续存在于这个世界的，正如太宰治的“生而为人，我很抱歉“，此时的真嗣是消极厌世的，他认为渚薰才是应该活下来的，而不是自己（哪怕为此牺牲了全人类）。他也不能接受自己杀了渚薰，认为自己杀了人，所以没有资格再活下去。\n\n> 真嗣：因为没有其他方法啊\n> 为什么杀掉\n> 真嗣：因为他是使徒啊\n> 即使同为人类？\n> 真嗣：不对，是使徒，他是我们的敌人\n> 即使同为人类？\n> 即使同为人类？\n> 真嗣：不对，不对，不对啊\n> 丽：明明跟我同样是人类啊\n> 真嗣：不对，他是使徒啊\n> 丽：所以杀掉\n> 真嗣：没错，不那样的话我们会死掉，大家都会被杀掉\n> 丽：所以杀掉\n> 真嗣：我也不想那么做，可是没有办法啊\n\n这里可以看出真嗣内心已经接近崩溃，虽然找出了很多理由来辩解为什么自己应该存在，辩解自己为什么应该杀死渚薰，但是反复出现的“所以杀掉”暗示了真嗣内心是不接受自己的辩解的，于是他选择了向他人求助，告诉他杀死渚薰、自己活下来的理由\n\n![help](http://ooph3gs8p.bkt.clouddn.com//20171028230517_0XSs9x_屏幕快照%202017-10-28%20下午10.56.14.png \"help\")\n\n然后画面闪回了24话末真嗣与美里在夜晚的湖边交谈\n\n> 真嗣：没错，活下来的应该是薰才对，他比我这种人不知道好多少倍，应该是薰活下来才对\n> 美里：不对，能活下来的只有怀抱生存意志的人，放弃生存的意思，把一切寄托在徒具表像的希望上，真嗣你没有错\n\n但是基于第一个假设，我认为25话应发生在交谈之后，所以此处除了省钱之外，应该算作回忆，美里的解释并不是真嗣想要的答案，不过我认为这是作者想要呈现给观众的答案\n\n​\t*顺便说一下，这时的真嗣去医院寻找了明日香的帮助，但是并没有得到帮助，而是……对于这样下流的主角，我只能说放开那个女孩，这种罪孽让我来承受*\n\n![OGC](http://ooph3gs8p.bkt.clouddn.com//20171028232420_b9lRrz_屏幕快照%202017-10-28%20下午11.20.31.png \"OGC\")\n\n紧接着又是一连串字幕\n\n![](http://ooph3gs8p.bkt.clouddn.com//20171028231206_Vy6FdZ_屏幕快照%202017-10-28%20下午11.11.29.png)\n\n大概这就是真嗣现在的想法，他认为自己正在被灌输正义，实际上无论何种解释，自己都没有理由在存活于世，不如死去。\n\n![](http://ooph3gs8p.bkt.clouddn.com//20171028232833_0LxvnT_屏幕快照%202017-10-28%20下午11.28.22.png)\n\n> 不安\n> 真嗣：这样真的好吗？\n> 强迫观念\n> 真嗣：我不知道，我该怎么办才好，该怎么办才好啊？\n> 在害怕什么？\n> 真嗣：害怕什么\n>\n> 在害怕什么？\n> 真嗣：自已\n> 在害怕什么？\n> 真嗣：怕被讨厌\n> 在害怕什么\n> 真嗣：被谁\n> 在害怕什么\n> 真嗣：谁呢？\n> 在害怕什么\n> 真嗣：那是…爸爸。我被爸爸拋弃，被爸爸讨厌\n> 真嗣：被讨厌的话该怎么办，怎么办才好\n\n接下来的这一段内心独白，说明了真嗣害怕被碇源渡讨厌，一个简单而又单纯的理由，折射的却是一个自幼被抛弃、残缺而破碎的内心。虽说每个人的一生难免都会被父母所伤害，但是真嗣的个人经历正是造成他性格的重要原因。对于一个14岁的少年，一次又一次的被父亲逼着“杀人”，正常情况下谁都会崩溃，真嗣的内心一遍遍的追问自己为什么害怕，而他的自卑、罪恶感也一步步把自己推向崩溃的边缘\n\n随着镜头一转，来到一片白雾中\n\n![白雾](http://ooph3gs8p.bkt.clouddn.com//20171029230516_lPSu6W_白雾.png \"迷蒙\")\n\n象征了此时的真嗣已经迷失自我\n\n> 真嗣：这是那里，我该去那里才好，什么都看不见，什么都不知道\n>\n> 美里小姐，那个，你到那里去了\n>\n> 那个，接下来我该去那里\n>\n> 美里小姐，明日香，丽，冬二，剑介，加持先生，律子小姐，爸爸…妈妈…谁来告诉我，告诉我到底该怎么办才好\n\n迷蒙中真嗣渴望得到别人的帮助，但是这是无济于事的。依据第二个假设，真嗣内心中出现的他人只是自己根据记忆构建的他人形象，虽然说出来的台词很像他人真正所说的，不过毕竟是自己所构建的。自己永远不可能欺骗自己，除非自己放弃了\n\n此时画面中出现了初号机，并一把抓住了真嗣\n\n![省钱镜头的致敬](http://ooph3gs8p.bkt.clouddn.com//20171029231323_p7Kmuw_省钱.png \"省钱镜头的致敬\")\n\n> EVA初号机，结果，我只能驾驶它吗？甚至还要杀掉喜欢的人，照爸爸还有大家说的，再次驾驶著它去战斗吗？妈妈，说说话吧　回答我啊\n\n此时突然出现的初号机，我认为有两层含义，一个是根据《EoE》的剧情，真嗣在美里留下“大人的吻”之后来到了初号机面前，但是他并没有坐上驾驶室，这里也许说明了他为什么不愿意再驾驶EVA，任凭我香如何呼喊\n\n![](http://ooph3gs8p.bkt.clouddn.com//20171029233159_czQ3SH_2017-10-2911.30.38s.png)\n\n第二层意思我认为是紧接上面，害怕被父亲讨厌的真嗣为了讨好父亲，成为大家眼中的乖孩子，不自愿地驾驶EVA，驾驶EVA是他为了博得父亲好感的一个也是唯一一个途径，哪怕一次次被伤害，一次次逃走，最终他都会回来驾驶EVA。而这一次EVA又来到了他的眼前，说明了他内心的绝望与矛盾……人生也何尝不是如此\n\n> 为什么驾驶EVA\n> 真嗣：因为大家要我驾驶\n> 所以就驾驶EVA?\n> 真嗣：那是为了大家啊，有什么不对\n> 你是为了大家，为了他人驾驶EVA吗？\n> 真嗣：没错啊，这不是件好事吗？不是一件非常好的事情吗？这样大家就会称赞我，就会重视我\n>\n> 明日香：骗人，你是白痴吗？结果还不是为了自己，你总是这样动不动就为自己辩解\n> 真嗣：是吗\n> 明日香：为了他人而努力这种想法，本身就是一种轻松的生活方式\n> 真嗣：是这样吗？\n>\n> 明日香：简言之，真嗣你很寂寞\n> 真嗣：是吗\n>\n> 明日香：你这样不过是一种依赖罢了\n> 真嗣：或许真是这样吧\n> 明日香：你只是一昧盼著自己被人需要不是吗\n> 真嗣：也许是吧\n\n纵观整部作品，真嗣大部分时间都不是自愿驾驶EVA的，有时为了帮助他人有时是为了自己。正如明日香所说，真嗣选择了一个轻松的活法——通过取得别人的认同而实现自己的人生价值。根据弗洛伊德精神分析学的基本原则\n\n> 包括遗传的性格构造在内，人心理的发展是由幼时的经历决定的\n\n造成目前真嗣这一性格很有可能是因为真嗣的童年经历。为了自己不再被抛弃，真嗣拼命寻找一个存在于此的理由——驾驶EVA，但是当他已经无法再驾驶EVA的时候，既是自己再次成为无用之物的时候（潜意识中真嗣认为自己将会再次被抛弃）\n\n虽说我们都知道事实并不如此，但是这也是局外人的观点，此时此刻真嗣是既不愿意再驾驶EVA，又不得不驾驶EVA，也许这也能解释真嗣为何在此时选择轻生。\n\n顺便提一下这里明日香的观点十分有趣，让我想到了正义的伙伴——卫宫士郎\n\n![正义的伙伴](http://ooph3gs8p.bkt.clouddn.com//20171031182843_vlUz6J_f_17148b5d2f7d52732cb5e7c96925f8e81.jpeg \"正义的伙伴\")\n\n也许是奈须蘑菇受到了痞子的启发，卫宫士郎的理想就被人评价为“偷来的理想”，而在这里真嗣被明日香说成了是寂寞\n\n> 寂寞是想要别人理解你\n>\n> 孤独是没有人能理解你\n\n可谓是一针见血，真嗣渴望被关注，渴望被爱，也曾经努力过，试图改变过，不过最后他认为自己失败了\n\n> 明日香：你只是一种等待別人给你幸福不是吗？给你虚假的幸福？\n> 丽：这方面你不也一样吗？\n> 明日香：啊？\n\n这时话锋一转，突然出现的绫波丽把矛头指向了明日香画面切到了水中的二号机（正好能和剧场版中昏迷的明日香同二号机一起沉入湖底避难）\n\n## 明日香与绫波丽\n\n> 明日香：不知不觉我又坐上了EVA，又被放了上来，反正这个废物也不会动了，不…废物应该是我吧，没人需要我这种人了，我这种人已经没人要了，没有人需要无法驾驶EVA的驾驶员\n> 丽：你在別人心中追寻自己呢\n>\n> 明日香：少啰嗦\n> 害怕分离\n> 丽：你害怕独自一人对吧？\n>\n> 改变话题，场景\n>\n> 害怕分离\n> 丽：你是因为自己也会和別人一起消失才害怕的吧？\n>\n> 害怕分离\n> 幼年的明日香：所以才驾驶EVA\n\n 明日香在剧中一贯给人开朗活泼的感觉，但是随着剧情的发展，明日香的精神状态急转直下。无法驾驶EVA的明日香离家出走并割腕自杀，说起来真的和真嗣很像。不过真嗣应属于被动型人格，明日香则正好相反，但是本质上他们都因为童年的阴影\n\n> 明日香：少啰嗦\n> 固执\n> 明日香：少啰嗦、少啰嗦，我才不想被妳这种人偶说教\n\n\n\n\n\n---\n\n\n\n\n"}]